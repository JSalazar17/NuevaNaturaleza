import { Component, OnInit, inject, forwardRef, Inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MAT_DIALOG_DATA, MatDialogModule, MatDialogRef } from '@angular/material/dialog';
import { MatCardModule } from '@angular/material/card';
import { MatDividerModule } from '@angular/material/divider';
import { Observable, map, startWith, switchMap } from 'rxjs';

import { Dispositivo } from '../../models/dispositivo.model';
import { TipoDispositivo } from '../../models/tipodispositivo.model';
import { TipoMedicion } from '../../models/tipomedicion.model';
import { TipoDispositivoService } from '../../services/tipodispositivos.service';
import { DispositivoService } from '../../services/dispositivos.service';
import { Actuador } from '../../models/actuador.model';
import { Sensor } from '../../models/sensor.model';
import { PuntoOptimo } from '../../models/puntoOptimo.model';
import { Accion } from '../../models/accion.model';
import { TipoMUnidadM } from '../../models/tipoMUnidadM.model';
import { AccionService } from '../../services/accion.service';
import { TipoMUnidadMService } from '../../services/tipoMUnidadM.service';
import { Marca } from '../../models/marca.model';
import { MarcaService } from '../../services/marcas.service';


@Component({
  selector: 'app-agregar-dispositivo',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatButtonModule,
    MatIconModule,
    MatAutocompleteModule,
    MatDialogModule,
    MatCardModule,
    MatDividerModule,
    
],
  templateUrl: './agregar-dispositivo.html',
  styleUrl: './agregar-dispositivo.css'
})
export class AgregarDispositivo implements OnInit {


  constructor(
  
  private dialogRef: MatDialogRef<AgregarDispositivo>,
  @Inject(MAT_DIALOG_DATA) public data: any,

  // servicios (inject)
  private tipoSvc : TipoDispositivoService,
  private tipoMsvc :TipoMUnidadMService,
  private accionSvc :AccionService,
  private marcaSvc :MarcaService,
  private dispSvc :DispositivoService,
) {
   
}
 fb= inject(FormBuilder);
  form = this.fb.group({
    nombre: ['', Validators.required],
    sn: ['', Validators.required],
    descripcion: [''],
    image: [''],
    idTipoDispositivo: ['', Validators.required],
    idMarca: [null as string | Marca | null],           // campo de texto que usaremos con autocomplete
    marca: [null],           // si no existe idMarca, enviar marca: Marca { idMarca, nombre }
    sensors: this.fb.array([]),
    actuadores: this.fb.array([])
  });



  marcasList:Marca[];
  // datos como observables
  tipos$!: Observable<TipoDispositivo[]>;
  tipoMUnidades$!: Observable<TipoMUnidadM[]>
  acciones$!: Observable<Accion[]>;
  // autocomplete marcas
  marcasFiltered$!: Observable<Marca[]>;

  // cache local (también puedes usar async pipe en template)
  allTipoMUnidades: TipoMUnidadM[] = [];

  loading = false;
  errorMsg = '';

  //esta en modo edicion
  isEditMode = false; 


  ngOnInit(): void {
    
  if (this.data?.dispositivo) {
    this.isEditMode = true;
    this.form.patchValue(this.data.dispositivo);
  }

    // cargar listas como observables (sin suscribir en componente)
    this.tipos$ = this.tipoSvc.obtenerTiposDispositivo(); // Observable<TipoDispositivo[]>
    this.tipoMUnidades$ = this.tipoMsvc.getTipoMUnidadMs();
    this.acciones$ = this.accionSvc.getAcciones();

    // cache de tipoMUnidades para filtrados
    this.tipoMUnidades$.subscribe(xs => this.allTipoMUnidades = xs || []);
    this.marcaSvc.obtenerMarcas().subscribe(ms=>{
      this.marcasList=ms
    })
    // marcas: autocomplete -> escuchamos valueChanges del control idMarca
this.marcasFiltered$ = this.form.get('idMarca')!.valueChanges.pipe(
  startWith(''),
  map(value => {
    const term = typeof value === 'string' ? value.toLowerCase() : value?.nombre?.toLowerCase() ?? '';
    return this.marcasList.filter(m => m.nombre.toLowerCase().includes(term));
  })
);


    // cuando cambia el tipo de dispositivo, limpiar arrays
    this.form.get('idTipoDispositivo')!.valueChanges.subscribe(_ => {
      this.clearArrays();
    });
  }

  // ---------- FormArray getters ----------
  get sensors(): FormArray { return this.form.get('sensors') as FormArray; }
  get actuadores(): FormArray { return this.form.get('actuadores') as FormArray; }

  // ---------- agregar / eliminar ----------
  addSensor() {
    const g = this.fb.group({
      idTipoMedicion: ['', Validators.required],   // primer combobox (tipo medición)
      idTipoMUnidadM: ['', Validators.required],   // segundo combobox (id tipoMUnidadM)
      valorMin: [null, Validators.required],
      valorMax: [null, Validators.required]
    });
    this.sensors.push(g);
    // visualmente los nuevos aparecerán arriba vía CSS (column-reverse)
  }
  removeSensor(i: number) { this.sensors.removeAt(i); }

  addActuador() {
    const g = this.fb.group({
      idAccionAct: ['', Validators.required],
      on: ['', Validators.required],
      off: ['', Validators.required]
    });
    this.actuadores.push(g);
  }
  removeActuador(i: number) { this.actuadores.removeAt(i); }

  // ---------- utilidades para opciones de unidad por sensor ----------
  getUnidadOptionsForSensorIndex(i: number): TipoMUnidadM[] {
    const g = this.sensors.at(i) as FormGroup;
    const idTipoMed = g?.get('idTipoMedicion')?.value;
    if (!idTipoMed) return [];
    return this.allTipoMUnidades.filter(x => x.idTipoMedicion === idTipoMed);
  }

  // ---------- helpers de modo (usa el nombre por defecto; cámbialo si tienes una propiedad en backend) ----------
  // Dado que trabajas con servicios existentes, en tu API tal vez tengas una propiedad que identifique si es sensor o actuador.
  // Aquí uso nombre como ejemplo.
  isSensorMode(tiposList: TipoDispositivo[] | null): boolean {
    const id = this.form.get('idTipoDispositivo')!.value;
    if (!id || !tiposList) return false;
    const t = tiposList.find(x => x.idTipoDispositivo === id);
    return !!t && (t.nombre?.toLowerCase().includes('sensor'));
  }
  isActuatorMode(tiposList: TipoDispositivo[] | null): boolean {
    const id = this.form.get('idTipoDispositivo')!.value;
    if (!id || !tiposList) return false;
    const t = tiposList.find(x => x.idTipoDispositivo === id);
    return !!t && (t.nombre?.toLowerCase().includes('actuador'));
  }

  // ---------- Guardar ----------
  save(): void {
    console.log(this.form)
    if (this.form.invalid) {
      this.form.markAllAsTouched();
      return;
    }
    this.loading = true;
    this.errorMsg = '';

    const val = this.form.value;

    // Mapear sensores: cada sensor -> Sensor + puntoOptimo[]
    const sensorsPayload: Sensor[] = (val.sensors || []).map((s: any) => {
      const punto: PuntoOptimo = {
        idTipoMunidadM: s.idTipoMUnidadM,
        valorMin: +s.valorMin,
        valorMax: +s.valorMax
      };
      return {
        idTipoMUnidadM: s.idTipoMUnidadM,
        medicions: [],
        puntoOptimos: [punto]
      } as Sensor;
    });

    const actuadoresPayload: Actuador[] = (val.actuadores || []).map((a: any) => ({
      idAccionAct: a.idAccionAct,
      on: a.on,
      off: a.off
    }));

    const payload: Dispositivo = {
      nombre: val.nombre!, // ⚡ aseguramos que no es null
      sn: val.sn!,
      descripcion: val.descripcion??undefined,
      image: val.image??undefined,
      idTipoDispositivo: val.idTipoDispositivo??undefined,
      sensors: sensorsPayload.length ? sensorsPayload : undefined,
      actuadores: actuadoresPayload.length ? actuadoresPayload : undefined
    };

    // Manejo idMarca / marca: si el control idMarca tiene un objeto Marca seleccionada,
    // mandamos idMarca. Si no, si el usuario escribió texto (y no existe id), mandamos marca:{idMarca: null, nombre: texto}
    const idMarcaVal = val.idMarca;
    if (idMarcaVal && typeof idMarcaVal === 'object' && idMarcaVal) {
      payload['idMarca'] = idMarcaVal.idMarca;
    } else if (idMarcaVal && typeof idMarcaVal === 'string' && idMarcaVal.trim()) {
      payload['idMarcaNavigation'] = { idMarca: null, nombre: idMarcaVal.trim() } as any;
    }

    // Llamada al servicio (sin suscribir arriba, pero aquí necesitamos ejecutar)
    // usando subscribe porque es la acción final; puedes transformar con lastValueFrom si quieres promesas.
    this.dispSvc.createDispositivo(payload).subscribe({
      next: () => {
        this.loading = false;
        // si estamos en un dialog, cerrarlo con resultado
        this.dialogRef?.close(true);
        // si no, limpiar form
        this.form.reset();
        this.clearArrays();
      },
      error: (err) => {
        this.loading = false;
        this.errorMsg = 'Error al guardar: ' + (err?.message || JSON.stringify(err));
      }
    });
  }

  clearArrays() {
    while (this.sensors.length) this.sensors.removeAt(0);
    while (this.actuadores.length) this.actuadores.removeAt(0);
  }

  // display function para el autocomplete (muestra nombre cuando se selecciona un objeto Marca)
  displayMarcaFn(m?: Marca) {
    return m ? m.nombre : '';
  }

  // función para cerrar (cuando se use como diálogo)
  close() {
    this.dialogRef?.close(false);
  }
}

